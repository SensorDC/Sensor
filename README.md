![figure](https://github.com/SensorDC/Sensor/blob/master/Sensor%20logo2.png)

# Project description

Sensor is Maven plugin which detects the dependency conflict issues that arise from referencing those APIs with identical method signatures but inconsistent behaviors across multiple library versions.

HomePage: https://sensordc.github.io

# Background 

Buildingsoftware projects on top of third-party libraries is a common practice to save development cost and improve software quality.
However, the heavy dependencies on third-party libraries often induce dependency conflict issues. 
When multiple versions of the same library class are present on the {\mycode classpath}, the Java class loader will load only one version and shadow the others. 
If the loaded version has inconsistent implementations with the intended but shadowed versions, dependency conflict issues will occur, inducing risks of runtime exceptions or unexpected program behaviors.

# Our goal（没动，需要根据论文改）

Decca aims to detect dependency conflict issues and assess their severity levels according to their impacts on the system and maintenance costs. The severity levels are defined as follows:

**Level 1:** the feature set referenced by host project is a subset of the actual loaded feature set. Besides, the shadowed version completely cover the feature set used by the host project. This indicates that any orders of the specification of these duplicate classes on the classpath will not induce serious runtime errors. Therefore, this is a benign conflict and will not affect the system reliability at runtime.

**Level 2:** the feature set referenced by host project is a subset of the actual loaded feature set. However, the shadowed feature set doesn’t cover the referenced feature set. It is considered as a potential risk for system reliability since different orders of the specifications of these duplicate classes on the classpath (e.g., in different running environment or building platform) might induce runtime errors. Compared with warnings at Level 1, warnings at Level 2 needs more costs to maintain.

**Level 3:** It is a harmful conflict, as the actual loaded feature set does not consume the feature set referenced by host project. The runtime errors will occur when the expected feature cannot be accessed. However, in this case, the shadowed feature set completely cover the feature set referenced by host project. Therefore, it can be solved by adjusting the dependency order on the classpath, without changing any source code.

**Level 4:** It is a harmful conflict, as the actual loaded feature set does not cover the referenced feature set. Besides, the shadowed feature set does not consume the referenced
feature set neither. Therefore, this type of conflicts can not be easily resolved by adjusting the dependency orders on the classpath. In this case, to solve these issues, it requires more efforts to ensure the multiple versions of classes could be referenced by host project.

# A quick example

We give an illustrative example code to describe how Sensor generates issue reports. As shown in Fig.1, host project directly depends on **a-1.0.jar**, **b-2.0.jar**, and libraries **b-1.0** are transitively introduced by **a-1.0.jar**. So that there are two versions of libraries **b** and **c** in the system. According to Maven’s nearest wins strategy, Maven chooses the version that appears at the nearest to the root (host project) of the dependency tree if there are multiple versions of the same library. In this case, only **b-2.0.jar** can be loaded. By analyzing the dependencies, methods **method_b()** (defined in library **b**) are referenced by host project. Actually, **method_b()** (defined in **b-2.0.jar**) and will be loaded, and **method_b()** (defined in **b-1.0.jar**) will be shadowed. For the dependency conflict issues, based on the above definition, Sensor can detect the semantic behavior difference caused by two methods with the same signature on the conflict dependency. The dependency issue report generated by Sensor is described in Fig.2.

![example1](https://raw.githubusercontent.com/SensorDC/Sensor/master/example1.jpg)

​																Figure 1 An illustrative example

![example2](https://raw.githubusercontent.com/SensorDC/Sensor/master/example2.jpg)

​											Figure 2 Dependency issue report generated by Sensor

```java
@Test(timeout = 4000)
public void test0() throws Throwable {
  Client client0 = null;
  try {
    cilent0 = new Client("DM7MPDx");
    fail("Expecting exception: NullPointerException");
  } catch(NullPointerException e){
  }
}
```

​									(a) A test generated for triggering SevConfig.getSize() by RIDDLE

```java
@Test(timeout = 4000)
public void test0() throws Throwable {
  Client client0 = new Client("AWS-size");;
  int int0 = client0.onStart();
  System.out.println(int0);
}
```

​									(a) A test generated for triggering SevConfig.getSize() by SENSOR

```java
Client.onStart() OutCome
1
```

​																					B-1.0.jar

```java
Client.onStart() OutCome
0
```

​																					B-2.0.jar

# License

Sensor is released under the MIT License.

# Environment

Mac or Linux operating system & JDK 1.8 & maven-3.6.0

# Reference

This project references the open source projects Soot, Apache Commons CSV, DOM4J.

# Contact author

wangying8052@163.com
